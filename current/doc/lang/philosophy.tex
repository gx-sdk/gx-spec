\section{Philosophy}

In order of importance, \gx{} is designed to accomplish the following:

\begin{enumerate}

{\bf \item Compile to fast and compact target system code.} If code
generated by \gx{} does not approach the performance of hand-compiled code
and compare with the performance of code generated from C, then \gx{}
offers no advantage over C. At that point, an abstraction layer built
of macros, wrappers, and compact C and assembly code, similar to \gx{}'s
predecessor {\tt genix-sdk}, would be at least as useful as \gx{}, since
many optimizing C compilers can generate code that performs very well. For
this reason, if a choice needs to be made between ease of optimization
and ease of use, ease of optimization will be chosen every time.

{\bf \item Leave the design of the software itself in the hands of the
programmer.} It's easy to design a system that locks the programmer into
a particular architecture, which would be leaning more toward framework
versus toolkit. \gx{} should be as flexible as possible, without sacrificing
optimizability or usability.

{\bf \item Abstract away common patterns.} This is another factor that's
important for making \gx{} stand out from existing solutions like C or
assembly. Tasks like loading and invoking Z80 code, loading sprites,
setting chip registers, etc. should be made as straightforward as possible
without sacrificing optimizability or flexibility.

\end{enumerate}
